# 消息收集机制说明

## 问题背景

在群聊场景中，用户可能分多次发送消息来报修，例如：
- 第一次："灯坏了"
- 第二次："在3-201"
- 第三次："客厅的灯"

系统需要收集这些消息，通过AI分析和判断，只有当信息完整时才调用下单系统。

## 解决方案

### 1. 消息上下文机制（MessageContext）

系统使用Redis存储消息上下文，支持：
- **多条消息收集**：按时间顺序存储用户的多条消息
- **消息合并**：AI分析时会合并所有历史消息和当前消息
- **图片支持**：支持收集多条消息中的多张图片
- **时间戳记录**：每条消息都有时间戳，便于判断消息时效性

### 2. 工作流程

```
用户发送消息1（信息不全）
    ↓
保存到消息上下文（Redis）
    ↓
AI分析：actionable=false，返回追问建议
    ↓
用户发送消息2（补充信息）
    ↓
AI分析：合并消息1+消息2，判断是否完整
    ↓
如果完整：actionable=true → 保存草稿 → 调用下单接口 → 清除消息上下文
如果不完整：actionable=false → 继续保存到消息上下文 → 返回追问建议
```

### 3. 消息收集规则

#### 3.1 消息保存条件
- ✅ 不是闲聊（intent != NOISE）
- ✅ 信息不全（actionable = false）
- ✅ 内容不为空且不是无意义回复

#### 3.2 消息合并规则
- 历史消息用"；"分隔合并
- 位置信息：当前消息优先（用户可能更正）
- 描述信息：合并所有描述
- 图片信息：收集所有图片，AI会分析所有图片

#### 3.3 消息清除条件
- ✅ 信息完整（actionable = true）→ 准备下工单
- ✅ 检测到更正消息 → 清除旧记忆，保存新消息
- ✅ 记忆过期（默认30分钟）→ 自动清除

### 4. AI分析增强

#### 4.1 提示词优化
提示词中明确要求AI：
1. **合并历史消息和当前消息**
2. **判断信息完整性**
3. **只有在信息完整时才设置 actionable=true**

#### 4.2 分析逻辑
```
AI分析时：
1. 获取消息上下文（包含所有历史消息）
2. 将历史消息合并为文本："消息1；消息2；消息3"
3. 结合当前消息，AI进行综合分析
4. 判断：
   - 如果合并后信息完整 → actionable=true
   - 如果合并后信息仍不全 → actionable=false，返回缺失信息
```

### 5. 下单触发条件

**只有在以下条件都满足时，才会调用下单接口：**

1. ✅ `actionable = true`（AI判断信息完整）
2. ✅ 意图为报修/投诉/咨询（不是闲聊）
3. ✅ 有位置信息（报修必须，投诉建议有）
4. ✅ 有描述信息

**下单流程：**
```
actionable=true
    ↓
保存草稿到数据库
    ↓
调用下单接口（如果启用）
    ↓
清除消息上下文（避免重复处理）
```

### 6. 配置说明

在 `application.properties` 中：

```properties
# 消息上下文有效期（分钟）
aiops.memory.expire-time=30

# 消息去重时间窗口（秒）
aiops.message.dedup-window=60

# 是否启用自动下单
aiops.order.enabled=false
```

### 7. 测试场景

#### 场景1：分多次发送完整信息

**消息1：**
```json
{
  "senderUserId": "user001",
  "groupId": "group001",
  "content": "灯坏了"
}
```
**预期：** actionable=false, status=NEED_MORE_INFO, 保存到消息上下文

**消息2（30秒后）：**
```json
{
  "senderUserId": "user001",
  "groupId": "group001",
  "content": "在3-201的客厅"
}
```
**预期：** AI合并消息1+消息2，actionable=true, status=SAVED, 调用下单接口

#### 场景2：带图片的消息收集

**消息1：**
```json
{
  "senderUserId": "user002",
  "groupId": "group001",
  "content": "漏水了",
  "imageUrl": "https://example.com/image1.jpg"
}
```

**消息2：**
```json
{
  "senderUserId": "user002",
  "groupId": "group001",
  "content": "在3-201的卫生间",
  "imageUrl": "https://example.com/image2.jpg"
}
```
**预期：** AI会分析两张图片，合并所有信息，判断完整性

#### 场景3：消息更正

**消息1：**
```json
{
  "senderUserId": "user003",
  "groupId": "group001",
  "content": "3-201的灯坏了"
}
```

**消息2（更正）：**
```json
{
  "senderUserId": "user003",
  "groupId": "group001",
  "content": "不对，是3-301的灯坏了"
}
```
**预期：** 检测到更正消息，清除旧记忆，使用新消息

### 8. 日志说明

关键日志：
- `使用消息上下文：senderId=xxx, 消息数=N` - 使用消息上下文进行分析
- `信息不全，保存到消息上下文等待补充` - 消息保存到上下文
- `信息已完整，清除消息上下文，准备下工单` - 信息完整，准备下单
- `构建多模态消息：senderId=xxx, 图片数=N` - 合并多张图片

### 9. 技术实现

#### 9.1 数据结构
- `MessageContext`：消息上下文对象
- `MessageItem`：单条消息项（包含内容、时间戳、图片URL）

#### 9.2 存储方式
- Redis Key：`aiops:context:{senderId}`
- 存储格式：JSON序列化的MessageContext对象
- 有效期：30分钟（可配置）

#### 9.3 兼容性
- 保留简单记忆方式（`aiops:memory:{senderId}`）用于兼容
- 新机制和旧机制可以并存

### 10. 优势

1. **智能收集**：自动收集用户的多条消息
2. **智能合并**：AI自动合并多条消息，提取完整信息
3. **智能判断**：AI判断信息是否足够完整
4. **容错处理**：支持消息更正、去重等
5. **图片支持**：支持收集和分析多张图片

### 11. 注意事项

1. **消息时效性**：默认30分钟内有效，超时自动清除
2. **消息去重**：相同内容在60秒内视为重复
3. **内存占用**：消息上下文存储在Redis，注意Redis内存
4. **并发处理**：同一用户的多条消息会按时间顺序处理

---

**总结**：系统通过消息上下文机制，智能收集和合并用户的多条消息，通过AI分析判断信息完整性，只有在信息完整时才调用下单接口，确保下单数据的准确性和完整性。
